<!-- Задача 3.
Вывести в консоль значения выражений и объяснить почему получились такие значения 
используя комментарии к каждому выражению: 
-->
<meta charset="utf-8">
<script>
"use strict";

/* !!! В виду ошибки в третьем выражении, данный код запускать не стоит !!! */

/* Значением данного выражения является строка "2010".
Так как внутри метода log операторы + имеют одинаковый приоритет, то указанная часть кода
выполняется последовательно слева направо. Таким образом, интрепретатор, увидев числовой операнд
10 и следующий за ним числовой операнд, производит арифметическое сложение указанных операндов,
далее так как следующим операндом является строка '10', то интерпретатор в виду нестрогой
типизации js, преобразует левый числовой операнд 20 в строку, и производит конкатенацию с правым
операндом.  
*/
console.log(10+10+"10");

/* Значением данного выражения является строка "101010".
Аналогично предыдущему примеру указанные в выражении операторы имеют одинаковый приоритет, ввиду
этого выражение выполняется слева направо. Так как первый и второй операнды имеют разные типы данных
и при этом один из операндов строка, то интрпретатор js преобразует числовой операнд в строковый. Таким
образом при первом действии выражения производится конкатенация двух строк, результатом которой является
"1010". Далее, так как аналогично предыдущему действию, один из операндов является числовым, то
интрпретатор преобразует числовой операнд в строку и производит конкатенацию.
*/
console.log(10+"10"+10);

/* В данном примере возбуждается ошибка ReferenceError.
Причиной тому служит следующее. Унарный опаратор автоинкремента имеет высший приоритет 
по отношению к оператору сложения или конкатенации, при этом унарные операторы правоассоциативны 
(Д.Фленеган - JavaScript подробное руководство, стр.90). Таким образом, первоначально должно быть выполнен выражение ++"10". Однако, такое выражение не может быть выполнено, так как операнд автоинкремента 
должен быть левосторонним выражением (такие выражения, которые могут стоять слева от оператора
присваивания). Данные, не присвоенные хотя бы переменной таким выражением не являются. Вместе с тем,
даже если бы здесь имелась переменная, то в любом случае возбуждалась бы ошибка ReferenceError, так
как после автоинкремента не производилось бы операций в виду отсутствия операторов слева от переменной.
В таком случае стоит предположить, что в данном примере подразумевалось преобразование строки в число и 
дальнейшее сложение преобразованного операнда с левым операндом. В этом варианте между ++ должен стоять пробел,
так как в противном случае интрпретатор воспринимает оператор ++ как автоинкремент.
*/
console.log(10+10+ +"10");

/* В следующем примере результатом выражения будет -Infinity.
Обусловлено это следующим, как было указано выше унарные операторы имеют наивысший приоритет.
Унарный минус преобразует свой операнд в числовой тип данных и изменяет знак результата.
Так как опарндом унарного минуса в настоящем примере является пустая строка, то при преобразовании
в число получается 0, а так как унарный минус изменяет знак результата, то получается -0.
Далее производится деление 10 на 0. В js допускается деление на 0, однако результатом выступает Infinity.
А так как деление производилось на -0, то результатом соответственно выступает -Infinity.  
*/
console.log(10/-"");

/* В данном выражении результатом является NaN, ввиду следующего:
Как и в вышеуказанных примерах, унарный плюс имеет наивысший приоритет, поэтому данная операция 
выполняется первой. Однако, в данном случае строка "2,5" не может быть преобразована к числу 2.5, так как
для отделения целой части в js использеутся `.`, а не ','. Таким образом, операция 
унарного сложения операнда, который не может быть преобразован к числовому типу возвращает значение NaN.
Соответственно, дальнейшие арифметические действия с операндами имеющими значения NaN в js возвращают
NaN.  
*/
console.log(10/+"2,5");
</script>