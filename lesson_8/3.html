<!--
3*. Программист решил сделать с помощью цикла for массив из функций, которые выводили бы цифры по порядку,
т.е. хотел получить нечто вроде:
```
var arr = [
    function() { console.log(0); },
    function() { console.log(1); },
    function() { console.log(2); },
];

arr[0](); // 0
arr[1](); // 1
arr[2](); // 2
```

решил программист это дело так:

```
var arr = [];
for (var i = 0; i < 3; i++) {
  arr.push(function() { console.log(i) });
}

arr[0](); // 3
arr[1](); // 3
arr[2](); // 3
```

Однако результат, который получает программист совершенно не тот, что ему нужен.
Исправьте ошибку программиста, покажите ему как реализовать решение используя и не используя нового
стандарта es6.

Решение:
  Проблема данной ситуации в том что, при создании функции в Scopes
  помещается i, которая является глобальной переменной из-за использования var
  , таким образом когда закончится итерации цикла, то Scopes функций
  будут ссылаться на текущие значения i. А значит в такой ситуации
  какой бы элемент массива мы не вызывали, будет получаться 3.

-->
<meta charset="UTF-8">
<script>
  // ES5. Для решения этой ситуции в стиле ES5 необходимо создать лексическое
  // окружение для функции, куда будут записываться и фиксироваться
  // значения счетчика цикла. Так как, первостепенно функция будет искать
  // значения из своего лексического окружения, то global переменные
  // проигнорируются. В данном случае удобно использовать замыкание.
  // Создадим функцию принимающую в качестве аргумента
  // значение счетчика, тем самым создавая лексическое
  // окружение для возвращающой функции
  var arr = [];
  for (var i = 0; i < 3; i++) {
    function bar(i) {
      return function() { console.log(i)}
    }
    arr.push(bar(i));
  }

  arr[0]();
  arr[1]();
  arr[2]();

  // Для ES6 решение лаконичнее, let переменные в отличие от var
  // не игнорируют область видимости внутри цикла. При этом в Scopes
  // функций кроме окружения global создаются еще и окружения script и block
  // При инициализации функции в block scope помещается текущее значение счетчика
  // и не перезаписывается при следующей итерации.

  let arr = [];
  for (let i = 0; i < 3; i++) {
    arr.push(function() { console.log(i); });
  }

  arr[0]();
  arr[1]();
  arr[2]();


</script>