/*
1) Для практикума из занятия 7 продумать, где можно применить замыкания

Предположим, что у нас к html подключено несколько скриптов, помимо змейки.
И в одном из скриптов также имеется объект settings. Соответственно оба объявленных
settings будут конфликтовать друг с другом. Если первым исполнится скрипт содержащий код игры змейка,
то соответственно переменная settings повлияет на settings из следующего скрипта и наоборот.
Используя замыкания, мы можем отграничить области видимости таким образом, что бы несколько скриптов не
конфликтовали друг с другом. Для этого следует обернуть весь скрипт содержащий код змейки в функцию и вызвать ее.
Такой подход позволяет создавать независимые модули.
см. папку - 1

2) Не выполняя кода, ответить, что выведет браузер и почему

  1.  if (!("a" in window)) {
        var a = 1;
      }
      alert(a);

Выведет undefined, так как переменная a, объявленная через var, будет создана и добавлена
в объект window при первом проходе интерпретатора до выполнения кода. Однако значение ей
присвоено не будет.


  2.  var b = function a(x) {
        x && a(--x);
      };
      alert(a);

Выведет undefined, так как переменная a не объявлена.
Интереснее было бы, если немного изменить функцию.

      var b = function a(x) {
        return x && a(--x);
      };
      alert(b(10));

В таком примере внутри функция вызывается рекурсиво с префиксным автодекрементом. В данной ситуации
не будет бесконечной рекурсии, так как логический оператор && применяет короткий цикл вычислений до первого ложного
значения. Таким образом, когда x дойдет до 0 - он будет воспринят как false и далее рекурсия начнет схлопываться
возвватив в итоге 0.

  3.  function a(x) {
        return x * 2;
      }
      var a;
      alert(a);

Так как одно и тоже имя назначено и функции и переменной, то интерпретатор будет использовать имя a
объявленное раньше. Раньше объявлена функция, однако она не вызвана как
функция, не переданы аргументы. Поэтому в браузере отобразиться функция и ее содержимое как текст.


  4.  function b(x, y, a) {
        arguments[2] = 10;
        alert(a);
      }
      b(1, 2, 3);

Отобразится 3. Дело в том, что изначально создаются переменные, которые принимают переданные
значения. Несмотря на то, что эти же значения будут переданы и в arguments, изменение
arguments не повлиет на переменную a.

  5.  function a() {
        alert(this);
      }

      a.call(null);

Отобразится null, так как через метод объекта функции call передано значение this равное null.
*/
