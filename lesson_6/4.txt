################################################################################################
4*. Задание-вопрос, ответить надо будет просто текстом.
В нашем приложении, "галерея", что делали на занятии, есть куски наподобие этих:

```
document
  .querySelector(this.settings.previewSelector)
  .addEventListener('click', event => this.containerClickHandler(event));
```
```
closeImageElement.addEventListener('click', () => this.close());
```

Почему в обоих случаях мы писали функцию, которая вызывает другую функцию? Т.е. мы ведь в
addEventListener должны передать строку на какое событие вешаем обработчик и функцию, которая
должна будет вызываться, почему например вместо:

```
closeImageElement.addEventListener('click', () => this.close());
```

мы не написали

```
closeImageElement.addEventListener('click', this.close);
```

Это ведь тоже было бы корректно и валидно, функция бы успешно запускалась при клике на элемент,
но почему мы так не сделали? Что меняется при разных вариантах? Почему?
Ответ запишите просто текстовым файлом.
Эта тема пока не пройдена, но хочется чтобы вы покопались, посмотрели в чем проблема.
#################################################################################################

1. С указанной ситуацией столкнулся при подготовке домашнего задания к 5 уроку.
Дело в том, что если передать addEventListener в качестве аргумента не стрелочную функцию, из которой
запускается необходимая функция обработчик, то свойство this внутри функции обработчика будет указывать на event,
а не на объект, внутри которого мы производим действия. Т.е., при передаче аргумента в виде имени функции
будет невозможно обратиться внутри нее через this к свойствам и методам объекта.

2. Если рассмотреть вопрос вне контекста объектов, то function declaration при вызове this из самой себя
вернет undefined, стрелочная же функция возвратит объект Window. Полагаю, что такое поведение как раз-
таки связано с возможностью this стрелочной функции возвращать объект вместо event. Т.е.,
скорее всего именно по этой причине и потребовалось введение в синтаксис js стрелочных функций.

3. Кроме того, в двух случаях различается смысл. При передаче в качестве аргумента
анонимной стрелочной функции из которой запускается именованая функция - для каждого элемента, события которого
обрабатываются, создается новая анонимная стрелочная функция. В случае передачи именнованной функции
передавалось бы ссылка на функцию. Но при данной ситуации это не особенно принципиально.